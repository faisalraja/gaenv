#
from distutils.sysconfig import get_python_lib
import os
import inspect
import argparse
import re
import pkg_resources
import sys

sys_path_build = """# Auto generated by gaenv
import sys
import os
sys.path.insert(0, os.path.dirname(__file__))"""


def main():
    parser = argparse.ArgumentParser(description='Command line utility for managing appengine thirdparty packages')
    parser.add_argument('--requirements', type=str, default='requirements.txt',
                        help='specify the requirements file default(requirements.txt)')
    parser.add_argument('--lib', type=str, default='gaenv_lib',
                        help='change the output dir, default is gaenv_lib')
    args = parser.parse_args()

    # Build requirements path & check for existence
    current_path = os.getcwd()
    requirement_path = os.path.join(current_path, args.requirements)
    if not os.path.exists(requirement_path):
        print 'requirements file %s not found' % requirement_path
        exit(0)

    with open(requirement_path, 'r') as file:
        requirements = [req for req in pkg_resources.parse_requirements(file.read())]

    links = []
    package_path = get_python_lib()
    for requirement in requirements:
        try:
            dist = pkg_resources.get_provider(requirement)
        except pkg_resources.DistributionNotFound:
            print 'Please install [%s]' % requirement
            continue
        except pkg_resources.VersionConflict:
            print 'Version don\'t match [%s] - create virtualenv or match the version' % requirement
            continue

        if dist.has_metadata('top_level.txt'):
            links.extend(dist.get_metadata_lines('top_level.txt'))

        if dist.has_metadata('dependency_links.txt'):
            links.extend(dist.get_metadata_lines('dependency_links.txt'))

    # Now we create the links
    if links:
        libs = os.path.join(current_path, args.lib)
        if not os.path.exists(libs):
            os.makedirs(libs)

        with open(os.path.join(libs, '__init__.py'), 'wb') as f:
            f.write(sys_path_build)

        for link in links:
            link = link.strip()
            symlink = os.path.join(package_path, link)
            if not os.path.exists(symlink) and os.path.exists(symlink + '.py'):
                symlink += '.py'
                dest = os.path.join(libs, link + '.py')
            else:
                dest = os.path.join(libs, link)

            if os.path.exists(symlink) and not os.path.exists(dest):
                os.symlink(symlink, dest)

            print 'Found and linked: %s' % link

        add_import = raw_input('Do you want to inject import to appengine_config.py? [yN]:').lower()
        if add_import == 'y':
            appengine_config = os.path.join(current_path, 'appengine_config.py')
            if not os.path.exists(appengine_config):
                print 'Creating %s' % appengine_config
                source_code = ''
            else:
                print 'Updating %s' % appengine_config
                with open(appengine_config, 'r') as f:
                    source_code = f.read()

            # Replace if there is no import
            import_statement = 'import %s' % args.lib
            if import_statement not in source_code:
                with open(appengine_config, 'wb') as f:
                    f.write(import_statement + '\n' + source_code)
                    print 'added [%s] in [%s]' % (import_statement, appengine_config)
            else:
                print 'already exists in [%s] skipping' % appengine_config


if __name__ == "__main__":
    main()